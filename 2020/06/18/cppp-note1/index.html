

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="Misaka Mikoto">
    
    <meta name="description" content="前言:第一次系统性地阅读cpp primer plus是在大一上学期期末左右，断断续续一直持续到了寒假才算是对整本书的大体框架有了一个大体的认识，完成了课后编程练习。

然后，由于大一下学期四门数学＋大物的缘故，我基本上就再没写过c++. 唯一写过几次c++，就是用仅存的知识帮高中同学解答问题，然而">
    
    

    
    <link rel="alternative" href="YOUR_RSS_ADDRESS" title="Misaka妙妙屋" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>cppp二周目补充笔记1-7 | Misaka妙妙屋</title>

    <!-- Bootstrap -->
    
<link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">

    
<link rel="stylesheet" href="/css/style.css">


    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script> 
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://Misaka9468.github.io" title="Misaka妙妙屋">Misaka妙妙屋</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index"><a href="/">首页</a></li>
                    
                    <li id="nav-archives"><a href="/archives">归档</a></li>
                    
                    
                    <li><a href="https://github.com/Misaka9468" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
    var backRoot = "/images/background/";
    var backArray = [ "1.png", "2.png", "3.png",  ];
        
    $(function() {
        // page-id...
        var pageId = "2020/06/18/cppp-note1/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";
        
        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>cppp二周目补充笔记1-7</h1>
        
        <div class="time-info">
发表于:<time datetime="2020-06-18T12:34:31.000Z" itemprop="datePublished">2020-06-18</time>，更新于:<time datetime="2020-06-20T14:50:26.463Z" itemprop="dateModified">2020-06-20</time>，By <a href="https://Misaka9468.github.io" title="Misaka Mikoto">Misaka Mikoto</a>
        </div>
        
        <div class="post-body-inner">
            <div id="toc" class="toc-article well">
                <strong class="toc-title">大纲</strong>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chpater-1-开始"><span class="toc-number">2.</span> <span class="toc-text">Chpater 1 开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-变量和基本类型"><span class="toc-number">3.</span> <span class="toc-text">Chapter 2 变量和基本类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-字符串、向量与数组"><span class="toc-number">4.</span> <span class="toc-text">Chapter 3 字符串、向量与数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-表达式"><span class="toc-number">5.</span> <span class="toc-text">Chapter 4 表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-语句"><span class="toc-number">6.</span> <span class="toc-text">Chapter 5 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-函数"><span class="toc-number">7.</span> <span class="toc-text">Chapter 6 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7-类"><span class="toc-number">8.</span> <span class="toc-text">Chapter 7 类</span></a></li></ol>
            </div>
            
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>第一次系统性地阅读cpp primer plus是在大一上学期期末左右，断断续续一直持续到了寒假才算是对整本书的大体框架有了一个大体的认识，完成了课后编程练习。</p>
<hr>
<p>然后，由于大一下学期四门数学＋大物的缘故，我基本上就再没写过c++. 唯一写过几次c++，就是用仅存的知识帮高中同学解答问题，然而事实证明我真的快忘完了。</p>
<p>终于在2020.6.18，我终于复习完了最后一门科目概率论与数理统计。一时间想起的事情就是再拾起c++，重刷cppp。</p>
<hr>
<p>阅读cppp二周目的预期目标: </p>
<ul>
<li><p><del>巩固</del> 拾起c++基本语法，达到能够用来刷oj的水平</p>
</li>
<li><p>补充在第一遍刷书的时候错过/没在意的知识</p>
</li>
</ul>
<h1 id="Chpater-1-开始"><a href="#Chpater-1-开始" class="headerlink" title="Chpater 1 开始"></a>Chpater 1 开始</h1><ul>
<li><p>写入endl，可以将与设备关联的缓冲区(buffer)中的内容刷到设备中，保证到目前为止程序所产生的所有输出都真正写入输出流中。</p>
</li>
<li><blockquote>
<p>while( std::cin &gt;&gt; value)</p>
</blockquote>
<p>实质上是用istream对象作为条件，遇到文件结束符(end-of-file)或无效输入(读入的值不符合类型) , istream对线使条件为假。</p>
</li>
</ul>
<h1 id="Chapter-2-变量和基本类型"><a href="#Chapter-2-变量和基本类型" class="headerlink" title="Chapter 2 变量和基本类型"></a>Chapter 2 变量和基本类型</h1><ul>
<li><p>wchar_t 16位 确保可以存放机器最大扩展字符集中的任意一个字符</p>
</li>
<li><p>char16_t 和 char32_t 为Unicode字符集服务</p>
</li>
<li><blockquote>
<p>unsigned char c = -1;   //    -1 % 256  =  255</p>
</blockquote>
<p>赋给无符号类型一个超过其范围的值，结果是初始值对无符号类型表示数值总数取模后的余数.</p>
</li>
<li><blockquote>
<p>int a=0;</p>
<p>int a= {0};</p>
<p>int a{0};</p>
<p>int a(0);</p>
</blockquote>
<p>四种初始化</p>
</li>
<li><blockquote>
<p>int a=10; //必须具有全局作用域</p>
<p>{</p>
<p>std:: cout &lt;&lt; :: a; //显式访问全局变量</p>
<p>}</p>
</blockquote>
</li>
<li><blockquote>
<p>int &amp;refVal = ival </p>
<p>int *p;</p>
<p>int *&amp;r= p; //指针的引用, 从右向左读，离变量名越近影响越直接</p>
</blockquote>
<p>引用必须初始化；引用可以理解为别名</p>
</li>
<li><p>初始化指针为nullptr (c++11) 或 0</p>
</li>
<li><p>void* 类型指针可以存放任意对象的地址</p>
</li>
<li><blockquote>
<p>typedef int arrT[10];  // arrT表示类型为int[10]</p>
<p>using arrT = int[10]; //与上条语句等价</p>
</blockquote>
</li>
<li><p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字</p>
</li>
<li><blockquote>
<p>const int *p = &val; //底层const，离p远，限定int</p>
<p>int *const p = &val; //顶层const，离p近，限定p</p>
</blockquote>
</li>
<li><blockquote>
<p>const auto f = ci;  // 希望推断出的auto是一个顶层的const</p>
</blockquote>
</li>
<li><blockquote>
<p>decltype( f() ) sum = x; // c++ 11 sum的类型就是函数f的返回类型</p>
</blockquote>
<p>decltype((variable))的结果永远是引用，而decltype(variable)结果只有在variable本身是一个引用时才是引用</p>
</li>
</ul>
<h1 id="Chapter-3-字符串、向量与数组"><a href="#Chapter-3-字符串、向量与数组" class="headerlink" title="Chapter 3 字符串、向量与数组"></a>Chapter 3 字符串、向量与数组</h1><blockquote>
<p>string s1 = “hello”;   //拷贝初始化，显式创建一个临时对象用于拷贝</p>
<p>string s2(“hello”);   // 直接初始化</p>
</blockquote>
<ul>
<li><p>getline( is , s ) 不包含换行符</p>
</li>
<li><p>string.size() 返回的是无符号整型数，在一条表达式中最好不要混用有符号类型如int</p>
</li>
<li><p>字符串字面值与string是不同的类型</p>
</li>
<li><p>遍历string</p>
<blockquote>
<p>for ( auto c: str) {               // str是一个string类对象</p>
<p>}</p>
</blockquote>
</li>
<li><p>修改string</p>
<blockquote>
<p>for (auto &amp;c: str) {      // 此时c是引用</p>
<p>}</p>
</blockquote>
</li>
<li><blockquote>
<p>vector&lt;int&gt; ivec(10,3);  // 填充10个值为3的int类型元素</p>
<p>ivec.push_back(4); //在尾部添加值为4的int类型元素</p>
</blockquote>
</li>
<li><blockquote>
<p>auto b = ivec.begin() ,  e = ivec.end();   //返回迭代器, 其中end方法返回的是尾后迭代器</p>
<p>int num =  *b;   //迭代器的解引用，得到迭代器指向的对线</p>
<p>auto it = ivec.cbegin();  // it的类型是vector<int>::const_iterator</p>
</blockquote>
<p>iter-&gt;mem 与 (*iter).mem 等价</p>
</li>
<li><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p>
</li>
<li><blockquote>
<p>int ia[]={0,1};</p>
<p>auto ia2(ia);  // ia2 是 int*</p>
<p>int *beg = end(ia);  // begin与end函数返回的是指针，且end()返回的是尾后指针</p>
</blockquote>
</li>
<li><p>使用数组初始化vector，只需指明拷贝区域的首元素地址与尾后地址</p>
<blockquote>
<p>int arr[]={0,1,2,3};</p>
<p>vector&lt;int&gt; ivec( begin(arr) , end(arr) );</p>
</blockquote>
</li>
<li><blockquote>
<p>for auto(auto &amp;row : ia)       //外层数组ia的每一个元素</p>
<p>​       for(auto col: row)           //对于内层数组的每一个元素</p>
</blockquote>
<p>将外层循环的控制变量声明成引用类型，避免数组被自动转换成指针，否则程序将在int*内遍历，显然不科学</p>
</li>
</ul>
<h1 id="Chapter-4-表达式"><a href="#Chapter-4-表达式" class="headerlink" title="Chapter 4 表达式"></a>Chapter 4 表达式</h1><ul>
<li><p>短路求值</p>
<ul>
<li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li>
<li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li>
</ul>
</li>
<li><p>移位运算符满足左结合律</p>
<blockquote>
<p>cout &lt;&lt; “1” &lt;&lt; “2” &lt;&lt; “3”;</p>
</blockquote>
</li>
<li><p>sizeof</p>
<ul>
<li>对指针执行sizeof运算得到指针本身所占空间的大小</li>
<li>对解引用指针执行sizeof匀速那得到指针指向的对象所占空间的大小</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象总的元素占用了多少空间</li>
</ul>
</li>
<li><p>强制类型转换:   <em>cast-name</em>&lt;<em>type</em>&gt;(<em>expression</em>);</p>
<ul>
<li><p><strong>static_cast</strong>: 任何具有明确定义的类型转换，只要不包含底层const都可以使用</p>
<blockquote>
<p>double slope = static_cast&lt;double&gt;(j) /i;</p>
</blockquote>
</li>
<li><p><strong>const_cast</strong>: 只能改变运算对象的底层const (去掉const性质)</p>
<blockquote>
<p>const char *pc;</p>
<p>char <em>p =  const_cast&lt;char\</em>&gt;(pc);</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Chapter-5-语句"><a href="#Chapter-5-语句" class="headerlink" title="Chapter 5 语句"></a>Chapter 5 语句</h1><ul>
<li><p>try语句块</p>
<blockquote>
<p>if(…)</p>
<p>​    throw exception(“”);</p>
<p>…</p>
<p>try {</p>
<p>​    <em>programs-statements</em></p>
<p>}    catch (<em>exception-declaration</em>) {           //接受throw抛出的异常</p>
<p>​            <em>handler-statements</em></p>
<p>}    catch (<em>exception-declaration</em>) {</p>
<p>​            <em>handler-statements</em></p>
<p>}</p>
</blockquote>
</li>
<li><p>&lt;stdexcept&gt;定义的异常类</p>
<ul>
<li>runtime_error   只有在运行时才能检测出的问题<ul>
<li>range_error </li>
<li>overflow_error</li>
<li>underflow_error</li>
</ul>
</li>
<li>logic_error  程序逻辑错误<ul>
<li>domain_error   参数对应结果值不存在</li>
<li>invalid_argument</li>
<li>length_error 试图创建一个超出该类型最大长度的对象</li>
<li>out_of_range</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Chapter-6-函数"><a href="#Chapter-6-函数" class="headerlink" title="Chapter 6 函数"></a>Chapter 6 函数</h1><ul>
<li><p>传递引用：避免拷贝，且无修改需求可声明为常量引用</p>
<blockquote>
<p>void reset(int &amp;i){</p>
<p>i=0;</p>
<p>}</p>
<p>int j = 42;</p>
<p>reset( j );  //直接传递对象而无须传递对象的地址</p>
</blockquote>
</li>
<li><p>使用实参初始化形参时会忽略<strong>顶层const</strong></p>
<blockquote>
<p>void fcn (const int i);</p>
<p>void fcn (int i); // 错误：重复定义了fcn(int)</p>
<p>void fcn (int*);</p>
<p>void fcn (int* const); //重复声明了fcn(int*)</p>
<p>void fcn(const int*); //新函数，作用于指向常量的指针</p>
<p>void fcn(int&amp;);</p>
<p>void fcn(const int&amp;); //新函数，作用于常量引用</p>
</blockquote>
</li>
<li><p>数组引用形参,此时维度成为类型</p>
<blockquote>
<p>void print( int (&amp;arr) [3] ) {</p>
<p>} //现在维度是类型的一部分</p>
<p>int i[2]={1,2};</p>
<p>int j[3]={1,2,3};</p>
<p>print(i); //错误：参数不对应</p>
<p>print(j); //正确</p>
</blockquote>
</li>
<li><p>了解<strong>initializer_list形参</strong> c++11</p>
</li>
<li><p>了解<strong>初始化列表返回值</strong> c++11</p>
</li>
<li><p>函数复杂返回值的方法 c++11</p>
<ul>
<li><p>使用尾置返回类型 auto fun(int a) -&gt;int(*)[10]</p>
</li>
<li><p>使用decltype </p>
<blockquote>
<p>int odd[]={1,2,3};</p>
<p>decltype(odd) * fun(int a);</p>
</blockquote>
</li>
</ul>
</li>
<li><p>重载对作用域的一般性质没有改变：如果在内层作用域声明名字，它将隐藏外层作用域中声明的重载实体</p>
</li>
<li><p>了解<strong>默认实参</strong>：调用时只能只能忽略尾部的实参</p>
</li>
<li><p>了解<strong>内联函数</strong></p>
</li>
<li><p>重载函数匹配</p>
<ul>
<li><blockquote>
<p>void ff (int);</p>
<p>void ff (short);</p>
<p>ff(‘a’); //char提升成int,调用ff(int)</p>
</blockquote>
</li>
<li><blockquote>
<p>void manip (long);</p>
<p>void manip (float);</p>
<p>manip(3.14); // 二义性调用,类型为double的字面值既可以转换成float也可以转换成long</p>
</blockquote>
</li>
</ul>
</li>
<li><p>函数指针：</p>
<ul>
<li><p>使用重载函数的指针时，必须明确界定到底该选取哪个函数</p>
</li>
<li><blockquote>
<p>bool function(int);  //一个函数的声明</p>
<p>void fun( bool func(int) ); </p>
<p>void fun( bool (*func)(int) ); //与上一条语句等价，函数类型自动转化换成函数指针</p>
</blockquote>
</li>
<li><p>decltype作用于某个函数时，返回函数类型而非指针类型。故需要显式加上*</p>
<blockquote>
<p>int sum(int);</p>
<p>decltype(sum)* func(int); </p>
<p>//该func函数返回一个int(*)(int)类型 （即一个指向返回值为int，接受一个int参数的函数的指针)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Chapter-7-类"><a href="#Chapter-7-类" class="headerlink" title="Chapter 7 类"></a>Chapter 7 类</h1><ul>
<li><p>定义在类内部的函数是隐式的inline函数</p>
</li>
<li><p>类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类外。</p>
</li>
<li><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。</p>
<p>即 total.isbn() 等价于 Sales_data::isbn(&amp;total)</p>
</li>
<li><p>默认情况下, this的类型是指向类类型非常量版本的常量指针，不能将其绑定到一个常量对象上，也就使得我们不能在一个常量对象上调用普通的成员函数。</p>
<p>然而this是隐式的不会出现在参数列表中，因此允许把const关键字放在成员函数的参数列表之后。</p>
<p>这样使用const的成员函数被称为常量成员函数。</p>
<p><strong>常量对象，常量对象的引用或指针都只能调用常量成员函数</strong></p>
<blockquote>
<p>std::string isbn() const {return bookNo;}</p>
</blockquote>
</li>
<li><p><strong>在类的外部定义成员函数时</strong>：与类内的声明保持一致，且使用作用域运算符</p>
<blockquote>
<p>double Sales::avg_price() const {…}</p>
</blockquote>
<p>而定义<strong>类的非成员接口函数</strong>，则不需要</p>
</li>
<li><blockquote>
<p>return *this;     //有时是为了让函数模仿某些内置运算符，返回引用类型，即调用该函数的对象</p>
</blockquote>
</li>
<li><p>构造函数</p>
<ul>
<li><p>构造函数不能声明成const的</p>
</li>
<li><p>某些类不能依赖于合成的默认构造函数</p>
<ul>
<li>当该类已经由我们定义了一些其他的构造函数</li>
<li>合成的默认构造函数可能执行错误的操作 如给数组和指针对象初始化</li>
<li>如果类中包含一个其他类类型的成员并且这个成员的类型没有默认构造函数</li>
</ul>
</li>
<li><p>可使用</p>
<blockquote>
<p>Sales_data() = default; //显式指明需要一个默认构造函数</p>
<p>Sales_data(const std::string &amp;s): bookNo(s) {}  //花括号内理解为”副作用”，一般为空</p>
<p>// 真正构造的实现是在参数列表后,被称为构造函数初始值列表,可以为空，构造由花括号内完成</p>
<p>Sales_data(std::istream &amp;);   //在类内声明，而在类外进行定义(需要加上类作用域),没有返回类型</p>
</blockquote>
</li>
<li><p>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值，而不能用花括号为其提供初值。</p>
</li>
<li><p>最好避免使用某些成员初始化其他成员，最好用构造函数的参数作为成员的初始值。</p>
</li>
<li><p>默认构造函数的正确打开方式</p>
<blockquote>
<p>Sale_data obj(); //原意是声明一个类实例，并初始化；实际上定义了一个函数</p>
<p>Sale_data obj; //正确用法</p>
</blockquote>
</li>
</ul>
</li>
<li><p>private成员可以被类的成员函数访问，不能被类的非成员接口函数访问</p>
</li>
<li><p>友元: </p>
<ul>
<li><p>类的<strong>非成员接口函数</strong>若想访问类的非公有成员，可以在类内友元声明。在类外同样需要声明、定义。</p>
<p>即友元声明的作用是影响访问权限，并非普通意义上的声明。</p>
</li>
<li><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类的所有成员。</p>
<blockquote>
<p>class Screen{</p>
<p>​    friend class Windows_mgr; //现在Windows_mgr类的成员函数可以访问Screen类的所有成员</p>
<p>}</p>
</blockquote>
</li>
<li><p>也可以仅令另一个类的某成员函数作为友元</p>
<blockquote>
<p>class Screen{</p>
<p>​    friend void Windows_mgr::fun(int) ; //现在成员函数 void fun(int) 可以访问Screen类的所有成员</p>
<p>}</p>
</blockquote>
<p>一个类想把一组重载函数声明为它的友元，它需要对这组函数中的每一个分别声明。</p>
</li>
</ul>
</li>
<li><p><strong>可变数据成员</strong></p>
<p>在数据类型前加mutable, 则即使是一个const对象的该成员的值也可以修改。 </p>
<p>可用于追踪成员函数被调用了多少次</p>
</li>
<li><p>类内初始值必须使用=的初始化形式或花括号的直接初始化形式。</p>
</li>
<li><p>一个const成员函数如果以引用好的形式返回<em>this ,那么它的返回类型将是常量引用，得到的是一个常量对象。即使调用该成员函数的原对象是非const类型。*</em>这意味着不能利用返回的对象来调用某些需要改变类内成员值的成员函数**。</p>
</li>
<li><p>基于const的重载：通过区分成员函数是否是const的，可以对其进行重载。</p>
<p>具体方法：重载一个<strong>常量成员函数</strong></p>
<p>若常量成员函数返回引用时，应对应地返回常量引用</p>
</li>
<li><p>对于两个类来说，即使它们的成员完全一样，这两个类也不是同一个类型。</p>
</li>
<li><p>一个类的成员类型不能是类本身，但可以是指向其自身类型的引用或指针。</p>
</li>
<li><p>作用域和定义在类外部的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Window_mgr::Screenindex <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ScreenIndex是Window_mgr类内的一个成员</span></span><br><span class="line">    <span class="comment">// 编译器在处理参数列表之前已经明确了我们位于Window_mgr类内作用域，故在参数及函数体内</span></span><br><span class="line">    <span class="comment">// 访问类内成员不需要加作用域符</span></span><br><span class="line">    <span class="comment">// 而返回值类型在函数名前，故若返回Window_mgr类内成员，还需要加上作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>了解<strong>委托构造函数</strong> c++11</p>
</li>
<li><p>隐式的类类型转换：<strong>能通过一个实参调用的构造函数</strong>定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sale_data定义了一个combine成员函数，接受一个Sale_data&amp;类型参数</span></span><br><span class="line"><span class="comment">// Sale_data定义了一个只接受string的构造函数</span></span><br><span class="line">Sale_data item;</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">word</span> = <span class="string">"hello"</span>;</span><br><span class="line">item.combine(<span class="keyword">word</span>); <span class="comment">//编译器用给定的string自动创建了一个临时sale_data对象</span></span><br><span class="line"><span class="comment">//只允许一步类型转换</span></span><br><span class="line">item.combine(<span class="string">"hello"</span>); <span class="comment">// 错误</span></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"hello"</span>)); <span class="comment">//正确</span></span><br><span class="line">item.combine(Sales_data(<span class="string">"hello"</span>)); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在构造函数的某个版本前面加explict，能够阻止隐式转换</p>
<p>此时使用该构造函数只能用于直接初始化</p>
<blockquote>
<p>Sale_data item(word); // 正确：直接初始化</p>
<p>Sale_data item1= word; //错误</p>
</blockquote>
</li>
</ul>
</li>
<li><p>了解<strong>聚合类</strong>与<strong>字面值常量类</strong></p>
</li>
<li><p>类的静态成员</p>
<ul>
<li><p>成员声明前加关键字static ; 既可以是private也可是public ; 类型可以是常量、引用、指针、类类型、函数等。所有类共享这一个静态成员，不与任何对象绑定在一起</p>
</li>
<li><p>静态函数成员不包含this指针，不能声明成是const的，在函数体内也不能使用this指针。</p>
</li>
<li><p>类的静态函数的定义：</p>
<p>既可以在类的内部定义也可在类的外部定义，在类的外部定义时不能重复static关键字。</p>
</li>
<li><p>类的静态成员的使用方法:</p>
<blockquote>
<p>r = Account::rate(); //使用作用域运算符</p>
<p>r = ac.rate(); //通过某对象或引用</p>
<p>r = pac-&gt;rate(); // 通过指向Account对象的指针</p>
</blockquote>
</li>
<li><p>成员函数无需通过作用域运算符就能直接访问静态成员。</p>
</li>
<li><p>静态成员能做普通成员无法做到的：</p>
<ul>
<li><blockquote>
<p>class Bar{</p>
<p>static Bar mem; //可以</p>
<p>Bar mem; //不阔以</p>
<p>Bar* mem; //阔以</p>
<p>}</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>


			
            <section class="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2020/06/18/cppp-note1/" data-title="cppp二周目补充笔记1-7" data-url="https://Misaka9468.github.io/2020/06/18/cppp-note1/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"YOUR_DUOSHUO_SHORT_NAME"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>
        </div>
    </div>
</article>

    <footer id="footer">
    <div id="bottom-tip">
        Misaka妙妙屋
    </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/XadillaX/hexadillax" target="_blank">Hexadillax</a> 主题</small><br />
        <small>&copy; 2014 Misaka Mikoto</small>
    </footer>

    


</body>
</html>

