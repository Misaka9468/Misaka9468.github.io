

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="Misaka Mikoto">
    
    <meta name="description" content="Chapter 15 面向对象程序设计OOP：概述
面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。

继承（inheritance）：

通过继承联系在一起的类构成一种层次关系。

通常在层次关系的根部有一个基类（base class">
    
    

    
    <link rel="alternative" href="YOUR_RSS_ADDRESS" title="Misaka妙妙屋" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>cppp-note5 | Misaka妙妙屋</title>

    <!-- Bootstrap -->
    
<link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">

    
<link rel="stylesheet" href="/css/style.css">


    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script> 
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://Misaka9468.github.io" title="Misaka妙妙屋">Misaka妙妙屋</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index"><a href="/">首页</a></li>
                    
                    <li id="nav-archives"><a href="/archives">归档</a></li>
                    
                    
                    <li><a href="https://github.com/Misaka9468" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
    var backRoot = "/images/background/";
    var backArray = [ "1.png", "2.png", "3.png",  ];
        
    $(function() {
        // page-id...
        var pageId = "2020/06/27/cppp-note5/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";
        
        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>cppp-note5</h1>
        
        <div class="time-info">
发表于:<time datetime="2020-06-27T14:29:00.000Z" itemprop="datePublished">2020-06-27</time>，更新于:<time datetime="2020-06-30T15:01:36.870Z" itemprop="dateModified">2020-06-30</time>，By <a href="https://Misaka9468.github.io" title="Misaka Mikoto">Misaka Mikoto</a>
        </div>
        
        <div class="post-body-inner">
            <div id="toc" class="toc-article well">
                <strong class="toc-title">大纲</strong>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-15-面向对象程序设计"><span class="toc-number">1.</span> <span class="toc-text">Chapter 15 面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP：概述"><span class="toc-number">1.1.</span> <span class="toc-text">OOP：概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义基类和派生类"><span class="toc-number">1.2.</span> <span class="toc-text">定义基类和派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义基类"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义派生类"><span class="toc-number">1.2.2.</span> <span class="toc-text">定义派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换与继承"><span class="toc-number">1.2.3.</span> <span class="toc-text">类型转换与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数"><span class="toc-number">1.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象基类"><span class="toc-number">1.4.</span> <span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问控制与继承"><span class="toc-number">1.5.</span> <span class="toc-text">访问控制与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承中的类作用域"><span class="toc-number">1.6.</span> <span class="toc-text">继承中的类作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数与拷贝控制"><span class="toc-number">1.7.</span> <span class="toc-text">构造函数与拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚析构函数"><span class="toc-number">1.7.1.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合成拷贝控制与继承"><span class="toc-number">1.7.2.</span> <span class="toc-text">合成拷贝控制与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#派生类的拷贝控制成员"><span class="toc-number">1.7.3.</span> <span class="toc-text">派生类的拷贝控制成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承的构造函数"><span class="toc-number">1.7.4.</span> <span class="toc-text">继承的构造函数</span></a></li></ol></li></ol></li></ol>
            </div>
            
            <h1 id="Chapter-15-面向对象程序设计"><a href="#Chapter-15-面向对象程序设计" class="headerlink" title="Chapter 15 面向对象程序设计"></a>Chapter 15 面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><ul>
<li><p>面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。</p>
</li>
<li><p>继承（inheritance）：</p>
<ul>
<li><p>通过继承联系在一起的类构成一种层次关系。</p>
</li>
<li><p>通常在层次关系的根部有一个<strong>基类</strong>（base class）。</p>
</li>
<li><p>其他类直接或者简介从基类继承而来，这些继承得到的类成为<strong>派生类</strong>（derived class）。</p>
</li>
<li><p>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
</li>
<li><p>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）。</p>
</li>
<li><p>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。</p>
<blockquote>
<p>class Bulk_quote : public Quote{</p>
<p>…</p>
<p>};        //Bulk_quote是Quote的派生类</p>
</blockquote>
</li>
<li><p>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</p>
</li>
</ul>
</li>
<li><p>动态绑定（dynamic binding，又称运行时绑定）：</p>
<ul>
<li>使用同一段代码可以分别处理基类和派生类的对象。函数的运行版本由实参决定，即在运行时选择函数的版本。</li>
<li>当我们使用<strong>基类的引用（或指针）</strong>调用一个虚函数时将发生动态绑定。</li>
</ul>
</li>
</ul>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><ul>
<li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li>
<li>基类通过在其成员函数的声明语句前加上关键字<code>virtual</code>使得该函数执行<strong>动态绑定</strong>。</li>
<li>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明，而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</li>
<li>如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。</li>
<li>访问控制：<ul>
<li><code>protected</code> ： 基类和其派生类还有友元可以访问。</li>
<li><code>private</code> ： 只有基类本身和友元可以访问。</li>
</ul>
</li>
</ul>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><ul>
<li><p>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：<code>public</code>、<code>protected</code>、<code>private</code>。</p>
</li>
<li><p>派生类必须将其继承而来的成员函数中<strong>需要覆盖</strong>的那些重新声明。</p>
</li>
<li><p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
</li>
<li><p>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。(若该成员函数同时是const的，则override写在const之后)。如果派生类没有覆盖其基类中某个虚函数，则派生类会直接继承其在基类中的版本。</p>
</li>
<li><p><strong>派生类构造函数</strong>：派生类必须使用基类的构造函数去初始化它的基类部分。</p>
<blockquote>
<p>//Bulk_quote的构造函数实例</p>
<p>Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc):</p>
<p>​    Qoute(book,p), min_qty(qty), discount(disc); //前两个成员继承自基类</p>
</blockquote>
</li>
<li><p>派生类可直接使用基类的public和protected成员。</p>
</li>
<li><p>我们能将公有派生类型的对象绑定到基类的引用或指针上。（取决于派生列表）</p>
</li>
<li><p>静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。</p>
</li>
<li><p><strong>派生类的声明</strong>：声明中不包含它的派生列表。派生列表出现在派生类的定义时。</p>
</li>
<li><p>如果我们想使用某个类作为基类，则该类必须已经定义而非仅仅声明。</p>
</li>
<li><p>C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字<code>final</code>。</p>
</li>
</ul>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><ul>
<li><p>可以将派生类对象绑定到基类的指针或引用上。</p>
</li>
<li><p>不存在从基类向派生类的隐式类型转换。即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类到派生类的转换。</p>
<blockquote>
<p>Bulk_quote bulk; //Bulk_quote是Quote的派生类</p>
<p>Qoute *itemP = &bulk;</p>
<p>Bulk_quote *bulkP = itemP; //错误：不能将基类转换为派生类</p>
<p>//如果我们已知某个基类到派生类的转换是安全的，则可以使用static_cast。</p>
</blockquote>
</li>
<li><p>派生类向基类的自动类型转换只对指针或引用类型有效，<strong>对象之间不存在类型转换</strong>。</p>
<p>当我们用一个派生类对象为一个基类对象<strong>初始化或赋值</strong>时，会调用基类版本的构造函数与赋值函数，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
</li>
<li><p>和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针类。</p>
</li>
<li><p>静态类型与动态类型：</p>
<ul>
<li>静态类型：表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。</li>
<li>动态类型：变量或表达式表示的内存中的对象的类型，直到运行时才可知。</li>
<li>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</li>
</ul>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><p><strong>使用虚函数可以执行动态绑定</strong>。当且仅当对<strong>通过指针或引用调用虚函数</strong>时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。可推断出，通过非指针非引用调用虚函数时，对应的虚函数版本是确定的。</p>
</li>
<li><p>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。</p>
</li>
<li><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致，返回类型也必须与基类函数匹配，存在例外：当类的虚函数返回类型是类本身的指针或引用时，此规则无效。</p>
<blockquote>
<p>如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*,只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
</blockquote>
</li>
<li><p>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</p>
</li>
<li><p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为，编译器认为新定义的这个函数与基类中原有的函数是相互独立的，这意味着原虚函数并未被覆盖仍可见。</p>
</li>
<li><p>若基类某成员函数非虚函数，且其派生类的某成员函数在返回类型、函数名、参数列表与其完全一致，则在派生类中基类的成员函数被覆盖。</p>
</li>
<li><p>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。</p>
</li>
<li><p>我们还能把final写在成员函数后面（const后面），这样不允许派生类覆盖。</p>
</li>
<li><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</li>
<li><p>通常，只有成员函数（或友元）中的代码才需要使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数的机制。</p>
</li>
</ul>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><ul>
<li><p><strong>纯虚函数</strong>（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p>
<blockquote>
<p>class &lt;类名&gt;</p>
<p>{</p>
<p>virtual &lt;返回类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</p>
<p>…</p>
<p>};</p>
</blockquote>
</li>
<li><p>一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数仍然为纯虚函数，对应的类仍然为抽象类，还是不能实例化对象）调用纯虚函数的方法为：抽象类类名::纯虚函数名(实参表)</p>
</li>
<li><p>含有纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。不能创建抽象基类的对象。</p>
</li>
</ul>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul>
<li>受保护的成员：<ul>
<li><code>protected</code>说明符可以看做是<code>public</code>和<code>private</code>中和后的产物。</li>
<li>类似于私有成员，受保护的成员对类的用户来说是不可访问的。</li>
<li>类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">int</span> prot_mem; <span class="comment">//protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">//能访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>; <span class="comment">//不能访问Base::prot_mem</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>&#123;s.j=s.prot_mem=<span class="number">0</span>;&#125; <span class="comment">//正确: clobber可以访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="number">0</span>&#125;; <span class="comment">//错误：clobber不能访问Base的protected成员</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>派生访问说明符：</p>
<ul>
<li><p>对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。</p>
</li>
<li><p>派生访问说明符的目的是：控制派生类用户(包括派生类的派生类)对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base{}</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的。【即派生类的成员函数和友元可以访问这些成员，但对象以及派生类不可以】</p>
<blockquote>
<p>Priv_Drev d;</p>
<p>d.pub_mem(); //错误: pub_mem是基类成员 而Priv_Drev是private继承</p>
</blockquote>
</li>
</ul>
</li>
<li><p>友元关系不能继承。当一个类将另一个类声明为友元时，友元类的基类或者派生类不具有特殊的访问能力。</p>
</li>
<li><p>每个类负责控制自己的成员访问权限。例：基类Base有友元类Pal与派生类Sneaky，在友元类Pal中可以访问Sneaky类中继承Base而来的成员，而无法访问Sneaky类自己的成员。</p>
</li>
<li><p>派生类向基类转换的可访问性：对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的，反之则不行。</p>
<p>【即把继承而来的成员看作派生类的public/private/protected类型】</p>
<ul>
<li>只有当D公有地继承B时，<strong>用户代码</strong>才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li>
<li>不论D以什么方式继承B，<strong>D的成员函数和友元都能使用派生类向基类的转换</strong>；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有地或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
</li>
<li><p>改变个别成员的可访问性：使用<code>using</code>。</p>
<blockquote>
<p>class Derived : private Base{   //注意:private继承</p>
<p>public: </p>
<p>​    using Base::size;   //Derived的用户将可以使用size成员</p>
<p>protected:</p>
<p>​    using Base::n;          //Derived的派生类将能使用n </p>
<p>}</p>
</blockquote>
</li>
<li><p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；使用<code>struct</code>关键字定义的派生类是公有继承的。</p>
</li>
</ul>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><ul>
<li>每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</li>
<li>派生类的成员将隐藏同名的基类成员，即使形参列表不同，也不会当作重载函数处理。除非显式使用域作用符：d.Base::memcn();</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</li>
<li>名字查找与继承的步骤：<ul>
<li>首先按确定p(或obj)的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。</li>
<li>在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。</li>
<li>假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：<ul>
<li>如果mem是虚函数<strong>且</strong>我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果mem不是虚函数或者通过对象(而非引用或指针)进行的调用，则编译器将产生一个常规函数调用，根据静态类型进行调用。也就是说，基类指针即使关联了派生类，也无法使用派生类特有的非虚的成员函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span>Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//隐藏基类的memfcn</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d;Base b;</span><br><span class="line">b.memfcn(); <span class="comment">//调用Base::memfcn</span></span><br><span class="line">d.memfcn(<span class="number">10</span>); <span class="comment">//调用Derived::fcn</span></span><br><span class="line">d.memfcn(); <span class="comment">//错误：参数列表为空的memfcn被隐藏了</span></span><br><span class="line">d.Base::memfcn(); <span class="comment">//调用Base::memfcn</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用using声明语句可以把基类中某函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。</li>
</ul>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul>
<li><p>如果我们delete一个Quote*类型的指针，则该指针有可能实际上指向了一个Bulk_quote类型的对象。因此，编译器必须清楚它应该执行的是Bulk_quote的析构函数。</p>
<blockquote>
<p>class Quote{</p>
<p>public:</p>
<p>​    virtual ~Quote() = default; //动态绑定析构函数</p>
<p>}</p>
</blockquote>
</li>
<li><p>基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</p>
</li>
<li><p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</p>
</li>
<li><p>之前的准则：如果一个类需要析构函数，那么它同样也需要拷贝和赋值操作，而基类的析构函数是一个例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数，此时其内容为空。我们无法据此推断该基类是否还需要赋值运算符或拷贝构造函数。</p>
</li>
<li><p>虚析构函数将阻止合成移动操作。</p>
</li>
</ul>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><ul>
<li>基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。</li>
<li>基类和派生类与其他类情况类似，也会出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数，此外还有其他的方式：<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值函数或析构函数是被删除的函数或者不可访问，则派生类中<strong>对应的成员</strong>将是删除的。</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。</li>
<li>当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li>
</ul>
</li>
</ul>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><ul>
<li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</li>
<li>派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。</li>
</ul>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><ul>
<li>C++11新标准中，派生类可以重用其直接基类定义的构造函数。</li>
<li>如<code>using Disc_quote::Disc_quote;</code>，注明了要继承<code>Disc_quote</code>的构造函数。</li>
</ul>


			
            <section class="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2020/06/27/cppp-note5/" data-title="cppp-note5" data-url="https://Misaka9468.github.io/2020/06/27/cppp-note5/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"YOUR_DUOSHUO_SHORT_NAME"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>
        </div>
    </div>
</article>

    <footer id="footer">
    <div id="bottom-tip">
        Misaka妙妙屋
    </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/XadillaX/hexadillax" target="_blank">Hexadillax</a> 主题</small><br />
        <small>&copy; 2014 Misaka Mikoto</small>
    </footer>

    


</body>
</html>

