

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="Misaka Mikoto">
    
    <meta name="description" content="Chapter 11 关联容器
关联容器和顺序容器的不同：关联容器中的元素时按照关键字来保存和访问的。
关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 map和 set。

关联容器类型：



容器类型
解释



按顺序存储



map
关键数组：保存关键字-值对


se">
    
    

    
    <link rel="alternative" href="YOUR_RSS_ADDRESS" title="Misaka妙妙屋" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>cppp二周目补充笔记11-12 | Misaka妙妙屋</title>

    <!-- Bootstrap -->
    
<link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">

    
<link rel="stylesheet" href="/css/style.css">


    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script> 
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://Misaka9468.github.io" title="Misaka妙妙屋">Misaka妙妙屋</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index"><a href="/">首页</a></li>
                    
                    <li id="nav-archives"><a href="/archives">归档</a></li>
                    
                    
                    <li><a href="https://github.com/Misaka9468" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
    var backRoot = "/images/background/";
    var backArray = [ "1.png", "2.png", "3.png",  ];
        
    $(function() {
        // page-id...
        var pageId = "2020/06/22/cppp-note3/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";
        
        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>cppp二周目补充笔记11-12</h1>
        
        <div class="time-info">
发表于:<time datetime="2020-06-22T15:02:07.000Z" itemprop="datePublished">2020-06-22</time>，更新于:<time datetime="2020-06-25T04:16:22.436Z" itemprop="dateModified">2020-06-25</time>，By <a href="https://Misaka9468.github.io" title="Misaka Mikoto">Misaka Mikoto</a>
        </div>
        
        <div class="post-body-inner">
            <div id="toc" class="toc-article well">
                <strong class="toc-title">大纲</strong>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-11-关联容器"><span class="toc-number">1.</span> <span class="toc-text">Chapter 11 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字类型的要求"><span class="toc-number">1.1.</span> <span class="toc-text">关键字类型的要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pair"><span class="toc-number">1.2.</span> <span class="toc-text">pair</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关联容器操作"><span class="toc-number">1.3.</span> <span class="toc-text">关联容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关联容器迭代器"><span class="toc-number">1.3.1.</span> <span class="toc-text">关联容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加元素"><span class="toc-number">1.3.2.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除元素"><span class="toc-number">1.3.3.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下标操作"><span class="toc-number">1.3.4.</span> <span class="toc-text">下标操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找元素"><span class="toc-number">1.3.5.</span> <span class="toc-text">查找元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无序容器"><span class="toc-number">1.4.</span> <span class="toc-text">无序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无序容器对关键字类型的要求"><span class="toc-number">1.4.1.</span> <span class="toc-text">无序容器对关键字类型的要求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-12-动态内存"><span class="toc-number">2.</span> <span class="toc-text">Chapter 12 动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态内存与智能指针"><span class="toc-number">2.1.</span> <span class="toc-text">动态内存与智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr类"><span class="toc-number">2.1.1.</span> <span class="toc-text">shared_ptr类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接管理内存"><span class="toc-number">2.1.2.</span> <span class="toc-text">直接管理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr和new结合使用"><span class="toc-number">2.1.3.</span> <span class="toc-text">shared_ptr和new结合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#智能指针和异常"><span class="toc-number">2.1.4.</span> <span class="toc-text">智能指针和异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">2.1.5.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">2.1.6.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态数组"><span class="toc-number">2.2.</span> <span class="toc-text">动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new和数组"><span class="toc-number">2.2.1.</span> <span class="toc-text">new和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#智能指针与动态数组"><span class="toc-number">2.2.2.</span> <span class="toc-text">智能指针与动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allocator类"><span class="toc-number">2.2.3.</span> <span class="toc-text">allocator类</span></a></li></ol></li></ol></li></ol>
            </div>
            
            <h1 id="Chapter-11-关联容器"><a href="#Chapter-11-关联容器" class="headerlink" title="Chapter 11 关联容器"></a>Chapter 11 关联容器</h1><ul>
<li>关联容器和顺序容器的不同：关联容器中的元素时按照<strong>关键字</strong>来保存和访问的。</li>
<li>关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 <code>map</code>和 <code>set</code>。</li>
</ul>
<p><strong>关联容器类型</strong>：</p>
<table>
<thead>
<tr>
<th>容器类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>按顺序存储</td>
<td></td>
</tr>
<tr>
<td><code>map</code></td>
<td>关键数组：保存<code>关键字-值</code>对</td>
</tr>
<tr>
<td><code>set</code></td>
<td>关键字即值，即只保存关键字的容器</td>
</tr>
<tr>
<td><code>multimap</code></td>
<td>支持同一个键多次出现的<code>map</code></td>
</tr>
<tr>
<td><code>multiset</code></td>
<td>支持同一个键多次出现的<code>set</code></td>
</tr>
<tr>
<td>无序集合</td>
<td></td>
</tr>
<tr>
<td><code>unordered_map</code></td>
<td>用哈希函数组织的<code>map</code></td>
</tr>
<tr>
<td><code>unordered_set</code></td>
<td>用哈希函数组织的<code>set</code></td>
</tr>
<tr>
<td><code>unordered_multimap</code></td>
<td>哈希组织的<code>map</code>，关键字可以重复出现</td>
</tr>
<tr>
<td><code>unordered_multiset</code></td>
<td>哈希组织的<code>set</code>，关键字可以重复出现</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map的用法</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    ++word_count[<span class="keyword">word</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w:word_count)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; w.second; <span class="comment">//读取map里元素时，返回一个pair</span></span><br><span class="line"><span class="comment">//set的用法</span></span><br><span class="line"><span class="built_in">set</span>\&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"the"</span>,<span class="string">"But"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;<span class="keyword">word</span>)</span><br><span class="line">    <span class="keyword">if</span>(exclude.<span class="built_in">find</span>(<span class="keyword">word</span>) == exclude.<span class="built_in">end</span>())  <span class="comment">//等于尾后迭代器，等于没有找到</span></span><br></pre></td></tr></table></figure>

<h2 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h2><ul>
<li>对于有序容器，如果一个类型定义了行为正常的”&lt;”运算符，则可以将其用作关键字类型。默认是<code>&lt;</code>。</li>
<li>如果想传递一个比较的函数，可以这样定义：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs,<span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line">mutiset&lt;Sales_data,<span class="keyword">decltype</span>(compareIsbn)*&gt;bookstore(compareIsbn);</span><br><span class="line"><span class="comment">// decltype后使用*表示希望比较操作类型是一种函数指针类型</span></span><br><span class="line"><span class="comment">//用compareIsbn初始化bookstore对象 表示向bookstore添加元素时，调用compareIsbn来进行排序</span></span><br></pre></td></tr></table></figure>

<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><ul>
<li>在<code>utility</code>头文件中定义。</li>
<li>一个<code>pair</code>保存两个数据成员，两个类型不要求一样。</li>
</ul>
<p><strong>pair的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>pair p;</code></td>
<td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td>
</tr>
<tr>
<td><code>pair p(v1, v2);</code></td>
<td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td>
</tr>
<tr>
<td><code>pairp = {v1, v2};</code></td>
<td>等价于<code>p(v1, v2)</code></td>
</tr>
<tr>
<td><code>make_pair(v1, v2);</code></td>
<td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td>
</tr>
<tr>
<td><code>p.first</code></td>
<td>返回<code>p</code>的名为<code>first</code>的数据成员。</td>
</tr>
<tr>
<td><code>p.second</code></td>
<td>返回<code>p</code>的名为<code>second</code>的数据成员。</td>
</tr>
<tr>
<td><code>p1 relop p2</code></td>
<td>&lt; &gt; &lt;= &gt;=运算关系符按字典序定义。</td>
</tr>
<tr>
<td><code>p1 == p2</code></td>
<td>必须两对元素两两相等</td>
</tr>
<tr>
<td><code>p1 != p2</code></td>
<td>同上</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,int&gt; process(vector&lt;string&gt; &amp;v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(),v.back.<span class="built_in">size</span>()&#125;;  <span class="comment">//列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(); <span class="comment">//隐式构造返回值</span></span><br><span class="line">    	<span class="comment">//也可以是return make_pair(v.back(),v.back().size());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p><strong>关联容器额外的类型别名</strong>：</p>
<table>
<thead>
<tr>
<th>类型别名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>key_type</code></td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td>每个关键字关联的类型，只适用于<code>map</code></td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>map</code>，是<code>pair</code>; 对于<code>set</code>，和<code>key_type</code>相同。</td>
</tr>
</tbody></table>
<blockquote>
<p>set&lt;string&gt;::value_type v1; //v1是一个string  </p>
<p>map&lt;string, int&gt;::value_type v3 ; //v3是一个pair&lt;const string, int&gt;</p>
<p>map&lt;string, int&gt;::key_type v4; //v4是一个string</p>
<p>map&lt;string, int&gt;::mapped_type v5; //v5是一个int</p>
</blockquote>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><ul>
<li>解引用一个关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的值的引用。</li>
<li><code>set</code>的迭代器是<code>const</code>的。</li>
<li>遍历关联容器：使用<code>begin</code>和<code>end</code>，遍历<code>map</code>、<code>multimap</code>、<code>set</code>、<code>multiset</code>时，迭代器按<strong>关键字升序</strong>遍历元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>(); <span class="comment">//*map_it是一个指向pair&lt;const string,size_t&gt;对象的引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">//错误:关键字是const的</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通常不对关联容器使用泛型算法</strong> <ul>
<li>在实际过程中要么是把它当作一个源序列：使用泛型copy算法将元素从一个关联容器拷贝到另一个序列。</li>
<li>可以调用inserter将一个插入器绑定到一个关联容器。通过使用inserter可以将关联容器当作一个目的位置来调用另一个算法。</li>
</ul>
</li>
</ul>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><strong>关联容器<code>insert</code>操作</strong>：</p>
<table>
<thead>
<tr>
<th><code>insert</code>操作</th>
<th>关联容器</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.insert(v)</code> <code>c.emplace(args)</code></td>
<td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。 对于<code>map</code>和<code>set</code>，只有元素的关键字不存在<code>c</code>中才插入或构造元素。函数返回一个<code>pair</code>，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的<code>bool</code>值。对于<code>multimap</code>和<code>multiset</code>则会插入范围中的每个元素。</td>
</tr>
<tr>
<td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td>
<td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td>
</tr>
<tr>
<td><code>c.insert(p, v)</code> <code>c.emplace(p, args)</code></td>
<td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td>
</tr>
</tbody></table>
<p>向<code>map</code>添加元素：</p>
<ul>
<li><code>word_count.insert({word, 1});</code></li>
<li><code>word_count.insert(make_pair(word, 1));</code></li>
<li><code>word_count.insert(pair(word, 1));</code></li>
<li><code>word_count.insert(map::value_type (word, 1));</code></li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><strong>从关联容器中删除元素</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.erase(k)</code></td>
<td>从<code>c</code>中删除每个<strong>关键字</strong>为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。</td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器，若<code>p</code>指向<code>c</code>中的尾元素，则返回<code>c.end()</code></td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td>
</tr>
</tbody></table>
<h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p><strong><code>map</code>和<code>unordered_map</code>的下标操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c[k]</code></td>
<td>返回关键字为<code>k</code>的元素；如果<code>k</code>不在<code>c</code>中，添加一个关键字为<code>k</code>的元素，对其值初始化。</td>
</tr>
<tr>
<td><code>c.at(k)</code></td>
<td>访问关键字为<code>k</code>的元素，带参数检查；若<code>k</code>不存在在<code>c</code>中，抛出一个<code>out_of_range</code>异常。</td>
</tr>
</tbody></table>
<p>set类型不支持下标，因为set中没有与关键字相关联的”值”。</p>
<p>通常，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但对map则不然：当对一个map进行下标操作时，会获得一个mapped_type对象(value);但解引用一个map迭代器时，得到一个value_type对象(pair)</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p><strong>在一个关联容器中查找元素</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.find(k)</code></td>
<td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>不小于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td>
</tr>
</tbody></table>
<ul>
<li><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器。</li>
<li>下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code>。</li>
</ul>
<ul>
<li><p>如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。结合使用count与find，来寻找该关键字对应的所有值。</p>
<p>或者结合使用lower_bound与upper_bound，原因在于lower_bound是左闭，指向第一个指定关键字。</p>
<p>或者使用equal_range，此函数接受一个关键字，返回一个迭代器pair.若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器是最后一个匹配元素的尾后。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。</p>
</li>
</ul>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><ul>
<li>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符。</li>
<li>理论上哈希技术可以获得更好的性能。</li>
<li>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。</li>
</ul>
<p><strong>无序容器管理操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>桶接口</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.bucket_count()</code></td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td><code>c.max_bucket_count()</code></td>
<td>容器能容纳的最多的桶的数目</td>
</tr>
<tr>
<td><code>c.bucket_size(n)</code></td>
<td>第<code>n</code>个桶中有多少个元素</td>
</tr>
<tr>
<td><code>c.bucket(k)</code></td>
<td>关键字为<code>k</code>的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td></td>
</tr>
<tr>
<td><code>local_iterator</code></td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td><code>const_local_iterator</code></td>
<td>桶迭代器的<code>const</code>版本</td>
</tr>
<tr>
<td><code>c.begin(n)</code>，<code>c.end(n)</code></td>
<td>桶<code>n</code>的首元素迭代器</td>
</tr>
<tr>
<td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td>
<td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.load_factor()</code></td>
<td>每个桶的平均元素数量，返回<code>float</code>值。</td>
</tr>
<tr>
<td><code>c.max_load_factor()</code></td>
<td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td>
</tr>
<tr>
<td><code>c.rehash(n)</code></td>
<td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td>
</tr>
</tbody></table>
<p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的严肃也都会在同一个桶中。因此，无需容器的性能依赖于哈希函数的质量和桶的大小。</p>
<h3 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h3><ul>
<li>我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。但是我们不能直接定义关键字类型位自定义类类型的无序容器。我们必须提供我们自己的hash模板版本。</li>
<li>例如：为了能将Sale_data用作关键字，我们需要提供函数来替代==一年算符和哈希值计算函数。</li>
</ul>
<h1 id="Chapter-12-动态内存"><a href="#Chapter-12-动态内存" class="headerlink" title="Chapter 12 动态内存"></a>Chapter 12 动态内存</h1><ul>
<li>对象的生命周期：<ul>
<li>全局对象在程序启动时分配，结束时销毁。</li>
<li>局部对象在进入程序块时创建，离开块时销毁。</li>
<li>局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</li>
<li>动态分配对象：只能显式地被释放。</li>
</ul>
</li>
<li>对象的内存位置：<ul>
<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量。</li>
<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象。</li>
<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象。</li>
</ul>
</li>
</ul>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><ul>
<li>动态内存管理：<ul>
<li><code>new</code>：在动态内存中为对象分配空间并返回一个指向该对象的指针。</li>
<li><code>delete</code>：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</li>
</ul>
</li>
<li>智能指针：<ul>
<li>管理动态对象。</li>
<li>行为类似常规指针。负责自动释放所指向的对象。</li>
<li>智能指针也是模板。定义在头文件memory里。</li>
</ul>
</li>
</ul>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>shared_ptr sp</code> <code>unique_ptr up</code></td>
<td>空智能指针，可以指向类型是<code>T</code>的对象</td>
</tr>
<tr>
<td><code>p</code></td>
<td>将<code>p</code>用作一个条件判断，若<code>p</code>指向一个对象，则为<code>true</code></td>
</tr>
<tr>
<td><code>*p</code></td>
<td>解引用<code>p</code>，获得它指向的对象。</td>
</tr>
<tr>
<td><code>p-&gt;mem</code></td>
<td>等价于<code>(*p).mem</code></td>
</tr>
<tr>
<td><code>p.get()</code></td>
<td>返回一个内置指针，指向<code>p</code>所管理的对象。</td>
</tr>
<tr>
<td><code>swap(p, q)</code> <code>p.swap(q)</code></td>
<td>交换<code>p</code>和<code>q</code>中的指针</td>
</tr>
</tbody></table>
<p><strong>shared_ptr独有的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>make_shared&lt;T&gt;(args)</code></td>
<td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(q)</code></td>
<td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td>
</tr>
<tr>
<td><code>p = q</code></td>
<td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td>
</tr>
<tr>
<td><code>p.unique()</code></td>
<td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td>
</tr>
<tr>
<td><code>p.use_count()</code></td>
<td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td>
</tr>
</tbody></table>
<blockquote>
<p>shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;(10,’9’);  // 指向一个值为”999999999”的string</p>
</blockquote>
<ul>
<li><p>每个shared_ptr都有一个关联的计数器，我们称其为引用计数。</p>
</li>
<li><p>无论何时我们拷贝一个shared_ptr,计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或者将它作为参数传递给一个函数以及作为函数的返回值，它所关联的计数器就会递增。</p>
</li>
<li><p>当我们给shared_ptr赋予一个新值或是shared_pr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器就会递减。</p>
</li>
<li><p>shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存</p>
</li>
<li><p>如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p>
</li>
</ul>
<p><strong>使用动态内存的三种原因</strong>：</p>
<ul>
<li><p>程序不知道自己需要使用多少对象（比如容器类）。</p>
</li>
<li><p>程序不知道所需要对象的准确类型。</p>
</li>
<li><p>程序需要在多个对象间共享数据。</p>
<p>例如，我们希望一个类的所有对象共享一个底层的数据如vector。若定义成员为vector，则各对象之间不共享。解决办法为，我们为每个对象设置一个shared_ptr来管理动态分配的vector。此shared_ptr的成员将记录有多少个对象共享相同的vector，并在vecotr的最后一个使用者被销毁时释放vector.</p>
</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><ul>
<li><p>用<code>new</code>动态分配和初始化对象。</p>
<ul>
<li><p><code>new</code>无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。</p>
</li>
<li><blockquote>
<p>int *pi = new int(123);</p>
<p>string *ps = new string(10,’9’);</p>
<p>vector&lt;int&gt; *pv = new vector&lt;int&gt;{0,1,2,3};</p>
<p>string *ps = new string(); //值初始化为空string</p>
<p>int *pi1 = new int(); //值初始化为0，即*pi1为0</p>
</blockquote>
</li>
<li><p>一旦内存耗尽，会抛出类型是<code>bad_alloc</code>的异常。</p>
</li>
</ul>
</li>
<li><p>用<code>delete</code>将动态内存归还给系统。</p>
<ul>
<li>接受一个指针，指向要释放的对象。我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</li>
<li><code>delete</code>后的指针称为空悬指针（dangling pointer）。 可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。</li>
</ul>
</li>
<li><p>使用<code>new</code>和<code>delete</code>管理动态内存存在三个常见问题：</p>
<ul>
<li>1.忘记<code>delete</code>内存。</li>
<li>2.使用已经释放掉的对象。</li>
<li>3.同一块内存释放两次。</li>
</ul>
</li>
<li><p>坚持只使用智能指针可以避免上述所有问题。</p>
</li>
</ul>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p><strong>定义和改变shared_ptr的其他方法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>shared_ptr&lt;T&gt; p(q)</code></td>
<td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(u)</code></td>
<td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(q, d)</code></td>
<td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可调用对象<code>d</code>来代替<code>delete</code>。比如，d可以是某函数名。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td>
<td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>p.reset()</code></td>
<td>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td>
</tr>
<tr>
<td><code>p.reset(q)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>p.reset(q, d)</code></td>
<td>同上</td>
</tr>
</tbody></table>
<ul>
<li><p>不要使用get初始化另一个智能指针或为智能指针赋值：</p>
<blockquote>
<p>shared_ptr&lt;int&gt; p(new int(42));</p>
<p>int *q = p.get(); {</p>
<p>shared_ptr&lt;int&gt; m(q); </p>
<p>}  //程序块结束，m被销毁，它指向的内存被释放，则p悬挂.</p>
</blockquote>
</li>
<li><blockquote>
<p>p是一个shared_ptr</p>
<p>p = new int(1024); //错误：不能将一个指针赋予shared_ptr</p>
<p>p.reset(new int(1024)); //正确：p指向一个新对象</p>
</blockquote>
</li>
</ul>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><ul>
<li>如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。</li>
<li>智能指针使用的规范：<ul>
<li>不用相同的内置指针初始化（或<code>reset</code>）多个智能指针</li>
<li>不<code>delete get()</code>返回的指针。</li>
<li>如果你使用<code>get()</code>返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。</li>
<li>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器。</li>
</ul>
</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul>
<li><p>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。</p>
</li>
<li><p>不支持拷贝或者赋值操作。</p>
</li>
<li><p>类似shared_ptr,初始化unique_ptr必须采用直接初始化形式：</p>
<blockquote>
<p>unique_ptr&lt;int&gt; p2(new int(42));</p>
</blockquote>
</li>
<li><p>向后兼容：<code>auto_ptr</code>：老版本，具有<code>unique_ptr</code>的部分特性。特别是，不能在容器中保存<code>auto_ptr</code>，也不能从函数返回<code>auto_ptr</code>。</p>
</li>
</ul>
<p><strong>unique_ptr操作</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>unique_ptr&lt;T&gt; u1</code></td>
<td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T,D&gt; u2</code></td>
<td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T,D&gt; u(d)</code></td>
<td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td>
</tr>
<tr>
<td><code>u = nullptr</code></td>
<td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td>
</tr>
<tr>
<td><code>u.release()</code></td>
<td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td>
</tr>
<tr>
<td><code>u.reset()</code></td>
<td>释放<code>u</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(q)</code></td>
<td>释放<code>u</code>指向的对象,如果提供了内置指针q，令<code>u</code>指向<code>q</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(nullptr)</code></td>
<td>将<code>u</code>置空</td>
</tr>
</tbody></table>
<ul>
<li><p>调用release会切断unique_ptr和它原来管理的对象间的练习。release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。</p>
<blockquote>
<p>p2.release(); //错误: p2不会释放内存，并且我们丢失了指针</p>
<p>auto p = p2.release(); //正确，但我们必须记得delete(p);</p>
</blockquote>
</li>
<li><p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。</p>
<blockquote>
<p>//从函数返回一个unique_ptr</p>
<p>unique_ptr&lt;int&gt; clone(int p){</p>
<p>​    return unique_ptr&lt;int&gt; (new int(p));</p>
<p>} </p>
<p>//返回一个局部对象的拷贝</p>
<p>unique_ptr&lt;int&gt; clone(int p){</p>
<p>​    unique_ptr&lt;int&gt; ret(new int (p));</p>
<p>​    …</p>
<p>​    return ret;</p>
<p>}</p>
</blockquote>
</li>
<li><p>与表不同： 创建或reset一个提供指定类型的删除器</p>
<blockquote>
<p>// p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</p>
<p>unique_ptr&lt;objT,delT&gt; p (new objT, fcn);</p>
</blockquote>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul>
<li><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针。</li>
<li>指向一个由<code>shared_ptr</code>管理的对象，不改变<code>shared_ptr</code>的引用计数。</li>
<li>一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，不管有没有<code>weak_ptr</code>指向该对象。</li>
</ul>
<p><strong>weak_ptr操作</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>weak_ptr&lt;T&gt; w</code></td>
<td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td>
</tr>
<tr>
<td><code>weak_ptr&lt;T&gt; w(sp)</code></td>
<td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td>
</tr>
<tr>
<td><code>w = p</code></td>
<td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td>
</tr>
<tr>
<td><code>w.reset()</code></td>
<td>将<code>w</code>置为空。</td>
</tr>
<tr>
<td><code>w.use_count()</code></td>
<td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>
</tr>
<tr>
<td><code>w.expired()</code></td>
<td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td><code>w.lock()</code></td>
<td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>
</tr>
</tbody></table>
<ul>
<li><p>由于对象可能不存在，所以我们不能使用weak_ptr直接访问对象，而必须调用lock.</p>
<blockquote>
<p>if (shared_ptr&lt;int&gt; np = wp.lock() ){   //np作为判断条件，若非空shared_ptr，则条件成立</p>
<p>} //使用np进行操作</p>
</blockquote>
</li>
</ul>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><ul>
<li><p><code>new</code>一个动态数组：</p>
<ul>
<li><p>类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。</p>
</li>
<li><p>返回<strong>指向第一个对象的指针</strong>。</p>
</li>
<li><blockquote>
<p>int *p = new int[10]]; // 10个未初始化的int</p>
<p>int *p1 = new int [10]() ; // 10个值初始化为0的int</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>delete</code>一个动态数组：</p>
<ul>
<li><code>delete [] p;</code></li>
</ul>
</li>
<li><p><code>unique_ptr</code>和数组：</p>
<ul>
<li>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头）。</li>
</ul>
</li>
<li><blockquote>
<p>char arr[0] ; // 错误: 不能定义长度为0的数组</p>
<p>char *cp = new char[0]; // 正确: 但cp不能解引用 </p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>unique_ptr&lt;T[]&gt; u</code></td>
<td><code>u</code>可以指向一个动态分配的数组，整数元素类型为<code>T</code></td>
</tr>
<tr>
<td><code>unique_ptr&lt;T[]&gt; u(p)</code></td>
<td><code>u</code>指向内置指针<code>p</code>所指向的动态分配的数组。<code>p</code>必须能转换为类型<code>T*</code>。</td>
</tr>
<tr>
<td><code>u[i]</code></td>
<td>返回<code>u</code>拥有的数组中位置<code>i</code>处的对象。<code>u</code>必须指向一个数组。</td>
</tr>
</tbody></table>
<h3 id="智能指针与动态数组"><a href="#智能指针与动态数组" class="headerlink" title="智能指针与动态数组"></a>智能指针与动态数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int[]&gt; up(new int[10]); </span><br><span class="line"><span class="comment">//当一个unique_ptr指向一个数组时，我们不能使用点和箭头成员运算符，可以用下标运算符。</span></span><br><span class="line"><span class="comment">//shared_ptr不直接支持管理动态数组，如果希望其管理一个动态数组，必须提供自己定义的删除器</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],[](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span>[] p&#125;)</span></span>; <span class="comment">//传递一个lambda作为删除器</span></span><br><span class="line">sp.reset(); <span class="comment">//使用我们提供的lambda释放数组，它使用delete[]</span></span><br><span class="line"><span class="comment">// shared_ptr未定义下标运算符，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素</span></span><br></pre></td></tr></table></figure>

<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><ul>
<li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们将内存分配和对象构造分离开。</li>
<li>分配的是原始的、未构造的内存。</li>
<li><code>allocator</code>是一个模板。</li>
</ul>
<p><strong>标准库allocator类及其算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>allocator&lt;T&gt;a</code></td>
<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>
</tr>
<tr>
<td><code>a.allocate(n)</code></td>
<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td>
</tr>
<tr>
<td><code>a.deallocate(p, n)</code></td>
<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>
</tr>
<tr>
<td><code>a.construct(p, args)</code></td>
<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造<strong>一个对象</strong>。</td>
</tr>
<tr>
<td><code>a.destroy(p)</code></td>
<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>
</tr>
</tbody></table>
<ul>
<li><p>allocator分配的内存是未构造的</p>
<blockquote>
<p>allocator&lt;string&gt; alloc; //可以分配string的allocator对象</p>
<p>auto const p = alloc.allocate(n); //分配n个未初始化的string</p>
<p>auto q=p;   //需要保留p的值</p>
<p>alloc.construct(q++); //*q为空字符串</p>
<p>alloc.construct(q++,10,’c’) //*q为cccccccccc</p>
<p>//使用完对象后要用destroy来销毁构造的元素</p>
<p>while(q != p)  //最初q指向最后一个构造元素的尾后</p>
<p>​    alloc.destroy(–q);</p>
<p>alloc.deallocate(p,n); //在destroy后释放内存，指针p必须指向allocate分配的内存，大小参数n必须与调用allocate分配内存时提供的大小参数相同</p>
</blockquote>
</li>
</ul>
<p><strong>allocator伴随算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>uninitialized_copy(b, e, b2)</code></td>
<td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_copy_n(b, n, b2)</code></td>
<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td>
</tr>
<tr>
<td><code>uninitialized_fill(b, e, t)</code></td>
<td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_fill_n(b, n, t)</code></td>
<td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>
</tr>
</tbody></table>
<ul>
<li>定义在头文件<code>memory</code>中。</li>
<li>在给定目的位置创建元素，而不是由系统分配内存给他们。</li>
</ul>


			
            <section class="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2020/06/22/cppp-note3/" data-title="cppp二周目补充笔记11-12" data-url="https://Misaka9468.github.io/2020/06/22/cppp-note3/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"YOUR_DUOSHUO_SHORT_NAME"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>
        </div>
    </div>
</article>

    <footer id="footer">
    <div id="bottom-tip">
        Misaka妙妙屋
    </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/XadillaX/hexadillax" target="_blank">Hexadillax</a> 主题</small><br />
        <small>&copy; 2014 Misaka Mikoto</small>
    </footer>

    


</body>
</html>

